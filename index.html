import json
import os
from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import Message, WebAppData, InputMediaPhoto
from aiogram.utils.keyboard import ReplyKeyboardMarkup, KeyboardButton
from aiogram import Router

BOT_TOKEN = os.getenv("BOT_TOKEN")
CHAT_ID   = int(os.getenv("TARGET_CHAT_ID"))  # id —Å—É–ø–µ—Ä–≥—Ä—É–ø–ø—ã PP4Farm
THREADS_FILE = os.getenv("THREADS_FILE", "threads.json")

dp = Dispatcher()
router = Router()
dp.include_router(router)

# —Ö—Ä–∞–Ω–∏–ª–∏—â–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–π "–≤–æ–¥–æ—ë–º -> message_thread_id"
def load_threads():
    if os.path.exists(THREADS_FILE):
        with open(THREADS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

def save_threads(mapping):
    with open(THREADS_FILE, "w", encoding="utf-8") as f:
        json.dump(mapping, f, ensure_ascii=False, indent=2)

threads = load_threads()

def category_hashtag_and_emojis(category: str):
    cat = (category or "").strip().lower()
    if cat == "—Ñ–∞—Ä–º":
        return "#—Ñ–∞—Ä–º_PP4Farm", ""
    if cat == "—Ç—Ä–æ—Ñ–µ–π":
        return "#—Ç—Ä–æ—Ñ–µ–π_PP4Farm", "üí•"
    if cat == "—É–Ω–∏–∫–∞–ª—å–Ω–æ–µ":
        # –ø–æ –¢–ó ‚Äî —Ç–µ –∂–µ —Ç–µ–≥–∏, –ø–ª—é—Å üí•üå∏
        return "#—Ç—Ä–æ—Ñ–µ–π_PP4Farm", "üí•üå∏"
    # fallback
    return "#—Ñ–∞—Ä–º_PP4Farm", ""

def lake_hashtag(lake: str):
    m = {
        "–õ–æ—Å–∏–Ω–æ–µ": "#–ª–æ—Å–∏–Ω–æ–µ_PP4Farm",
        "–ö–æ–º–∞—Ä–∏–Ω–æ–µ": "#–∫–æ–º–∞—Ä–∏–Ω–æ–µ_PP4Farm",
        "–í—å—é–Ω–æ–∫": "#–≤—å—é–Ω–æ–∫_PP4Farm",
        "–ë–µ–ª–∞—è": "#–±–µ–ª–∞—è_PP4Farm",
        "–û—Å—Ç—Ä–æ–≥": "#–æ—Å—Ç—Ä–æ–≥_PP4Farm",
        "–ö—É–æ—Ä–∏": "#–∫—É–æ—Ä–∏_PP4Farm",
        "–ú–µ–¥–≤–µ–∂—å–µ": "#–º–µ–¥–≤–µ–∂—å–µ_PP4Farm",
        "–í–æ–ª—Ö–æ–≤": "#–≤–æ–ª—Ö–æ–≤_PP4Farm",
        "–î–æ–Ω–µ—Ü": "#–¥–æ–Ω–µ—Ü_PP4Farm",
        "–°—É—Ä–∞": "#—Å—É—Ä–∞_PP4Farm",
        "–õ–∞–¥–æ–∂—Å–∫–æ–µ": "#–ª–∞–¥–æ–∂—Å–∫–æ–µ_PP4Farm",
        "–ê—Ä—Ö–∏–ø–µ–ª–∞–≥": "#–∞—Ä—Ö–∏–ø–µ–ª–∞–≥_PP4Farm",
        "–Ø–Ω—Ç–∞—Ä–Ω–æ–µ": "#—è–Ω—Ç–∞—Ä–Ω–æ–µ_PP4Farm",
        "–ê—Ö—Ç—É–±–∞": "#–∞—Ö—Ç—É–±–∞_PP4Farm",
        "–ú–µ–¥–Ω–æ–µ": "#–º–µ–¥–Ω–æ–µ_PP4Farm",
        "–¢—É–Ω–≥—É—Å–∫–∞": "#—Ç—É–Ω–≥—É—Å–∫–∞_PP4Farm",
        "–Ø–º–∞": "#—è–º–∞_PP4Farm",
        "–ù–æ—Ä–≤–µ–∂—Å–∫–æ–µ –º–æ—Ä–µ": "#–Ω–æ—Ä–≤–µ–∂—Å–∫–æ–µ_PP4Farm",
    }
    return m.get(lake, "")

@router.message(Command("start"))
async def start(msg: Message):
    kb = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="–û—Ç–∫—Ä—ã—Ç—å —Ñ–æ—Ä–º—É", web_app={"url": os.getenv("WEBAPP_URL", "https://your-host/index.html")})]],
        resize_keyboard=True
    )
    await msg.answer("–û—Ç–∫—Ä–æ–π Mini App –∏ –æ—Ç–ø—Ä–∞–≤—å –ø–æ—Å—Ç.", reply_markup=kb)

@router.message(Command("bind"))
async def bind(msg: Message):
    # –∫–æ–º–∞–Ω–¥–∞ ¬´/bind –Ø–Ω—Ç–∞—Ä–Ω–æ–µ¬ª –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –ò–ú–ï–ù–ù–û –≤–Ω—É—Ç—Ä–∏ –Ω—É–∂–Ω–æ–π —Ç–µ–º—ã
    if not msg.is_topic_message or not msg.message_thread_id:
        await msg.reply("–≠—Ç—É –∫–æ–º–∞–Ω–¥—É –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –≤–Ω—É—Ç—Ä–∏ —Ç–µ–º—ã —Ñ–æ—Ä—É–º–∞.")
        return
    parts = msg.text.split(maxsplit=1)
    if len(parts) < 2:
        await msg.reply("–§–æ—Ä–º–∞—Ç: /bind <–ù–∞–∑–≤–∞–Ω–∏–µ –≤–æ–¥–æ—ë–º–∞>")
        return
    lake = parts[1].strip()
    threads[lake] = msg.message_thread_id
    save_threads(threads)
    await msg.reply(f"–°–≤—è–∑–∞–ª —Ç–µ–º—É {msg.message_thread_id} —Å –≤–æ–¥–æ—ë–º–æ–º ¬´{lake}¬ª.")

@router.message(F.web_app_data)
async def handle_webapp(msg: Message):
    data: WebAppData = msg.web_app_data
    try:
        payload = json.loads(data.data)
    except Exception as e:
        await msg.answer("–ù–µ —Å–º–æ–≥ –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ Mini App.")
        return

    if payload.get("type") != "post_form":
        await msg.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –∏–∑ Mini App.")
        return

    category = payload.get("category")
    lake     = payload.get("lake")
    fish     = payload.get("fish")
    coords   = payload.get("coordinates")
    depth    = payload.get("depth")
    clips    = payload.get("clips")
    speed    = payload.get("speed")
    square   = payload.get("square")
    comment  = payload.get("comment")
    photos   = payload.get("photos", [])[:10]

    if len(photos) < 3:
        await msg.answer("–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 3 —Ñ–æ—Ç–æ.")
        return

    cat_tag, emojis = category_hashtag_and_emojis(category)
    lake_tag = lake_hashtag(lake)

    # —Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å—å –¥–ª—è –ø–µ—Ä–≤–æ–π —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
    lines = [
        cat_tag + (f" {emojis}" if emojis else ""),
        lake_tag if lake_tag else "",
        f"üêü {fish}" if fish else "",
        f"üìå –¢–æ—á–∫–∞: {coords}" if coords else "",
        f"üé£ –ö–ª–∏–ø—Å–∞: {clips}" if clips else "",
        f"‚è¨ –ì–ª—É–±–∏–Ω–∞: {depth}" if depth else "",
        f"‚ö° –°–∫–æ—Ä–æ—Å—Ç—å: {speed}" if speed else "",
        f"üó∫ –ö–≤–∞–¥—Ä–∞—Ç: {square}" if square else "",
        f"üí¨ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {comment}" if comment else "",
    ]
    caption = "\n".join([l for l in lines if l])

    # —Å–æ–±–∏—Ä–∞–µ–º InputMediaPhoto
    media = []
    for i, url in enumerate(photos):
        if i == 0:
            media.append(InputMediaPhoto(media=url, caption=caption, parse_mode=ParseMode.HTML))
        else:
            media.append(InputMediaPhoto(media=url))

    thread_id = threads.get(lake)
    if not thread_id:
        await msg.answer(f"–î–ª—è ¬´{lake}¬ª –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω–∞ —Ç–µ–º–∞. –ê–¥–º–∏–Ω—É: –∑–∞–π–¥–∏—Ç–µ –≤ –Ω—É–∂–Ω—É—é —Ç–µ–º—É –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ /bind {lake}")
        return

    # –ø—É–±–ª–∏–∫—É–µ–º –≤ —Ç–µ–º—É
    await msg.bot.send_media_group(
        chat_id=CHAT_ID,
        message_thread_id=thread_id,
        media=media
    )
    await msg.answer("–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ ‚úÖ")

def main():
    from aiogram import asyncio
    bot = Bot(BOT_TOKEN, parse_mode=ParseMode.HTML)
    asyncio.run(dp.start_polling(bot))

if __name__ == "__main__":
    main()
